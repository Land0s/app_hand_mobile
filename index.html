<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>AR Triangle with Gesture Control</title>
  <!-- Подключаем A-Frame для AR -->
  <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
  <!-- Подключаем AR.js для маркерного AR -->
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
  <!-- Подключаем Three.js для создания треугольника -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- Подключаем Handsfree.js для отслеживания жестов -->
  <script src="https://unpkg.com/handsfree@8.5.1/dist/handsfree.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
    #ar-scene {
      width: 100vw;
      height: 100vh;
    }
    #gesture-info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      font-family: Arial, sans-serif;
    }
  </style>
</head>
<body>
  <!-- Контейнер для отображения информации о жестах -->
  <div id="gesture-info">Gesture: None</div>
  <!-- A-Frame сцена для AR -->
  <a-scene id="ar-scene" embedded arjs="sourceType: webcam; debugUIEnabled: false;">
    <!-- Камера -->
    <a-camera position="0 0 0"></a-camera>
    <!-- Маркер Hiro для позиционирования треугольника -->
    <a-marker preset="hiro">
      <!-- Сущность для треугольника -->
      <a-entity id="triangle" position="0 0 0" scale="0.5 0.5 0.5">
        <!-- Геометрия треугольника создается в коде -->
      </a-entity>
    </a-marker>
  </a-scene>

  <script>
    // Инициализация Handsfree.js
    const handsfree = new Handsfree({
      hands: true,
      setup: {
        video: { width: window.innerWidth, height: window.innerHeight }
      }
    });
    handsfree.start();

    // Получаем сущность треугольника
    const triangleEntity = document.getElementById('triangle');
    let scene, renderer, camera, triangleMesh;

    // Создаем 3D-треугольник с помощью Three.js
    function initTriangle() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      renderer = new THREE.WebGLRenderer({ alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);

      // Создаем геометрию треугольника
      const geometry = new THREE.BufferGeometry();
      const vertices = new Float32Array([
        0, 1, 0,   // Вершина 1
        -1, -1, 0, // Вершина 2
        1, -1, 0   // Вершина 3
      ]);
      const indices = [0, 1, 2];
      geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
      geometry.setIndex(indices);
      const material = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide });
      triangleMesh = new THREE.Mesh(geometry, material);
      scene.add(triangleMesh);

      // Привязываем Three.js объект к A-Frame сущности
      triangleEntity.object3D.add(triangleMesh);
    }

    // Инициализация треугольника
    initTriangle();

    // Переменные для отслеживания жестов
    let lastPinch = false;
    let initialPinchDistance = 0;
    let initialScale = 0.5;
    let lastHandX = 0;

    // Обработка жестов
    function handleGestures() {
      const hands = handsfree.data?.hands;
      if (!hands || !hands.landmarks || hands.landmarks.length === 0) {
        document.getElementById('gesture-info').innerText = 'Gesture: None';
        return;
      }

      const landmarks = hands.landmarks[0]; // Берем первую руку
      const thumbTip = landmarks[4]; // Кончик большого пальца
      const indexTip = landmarks[8]; // Кончик указательного пальца
      const wrist = landmarks[0]; // Запястье

      // Рассчитываем расстояние между большим и указательным пальцем (pinch)
      const pinchDistance = Math.sqrt(
        Math.pow(thumbTip.x - indexTip.x, 2) +
        Math.pow(thumbTip.y - indexTip.y, 2)
      );

      // Определяем жест сжатия (pinch)
      const isPinching = pinchDistance < 0.1; // Порог для сжатия
      if (isPinching && !lastPinch) {
        initialPinchDistance = pinchDistance;
        initialScale = triangleEntity.getAttribute('scale').x;
      }
      if (isPinching) {
        const scaleFactor = pinchDistance / initialPinchDistance;
        const newScale = initialScale * scaleFactor;
        triangleEntity.setAttribute('scale', `${newScale} ${newScale} ${newScale}`);
        document.getElementById('gesture-info').innerText = `Gesture: Pinch (Scale: ${newScale.toFixed(2)})`;
      }

      // Определяем поворот ладони (по углу запястья)
      const palmAngle = Math.atan2(indexTip.y - wrist.y, indexTip.x - wrist.x);
      triangleMesh.rotation.y = palmAngle;

      // Перемещение по горизонтали
      const handX = wrist.x;
      if (lastHandX !== 0) {
        const deltaX = (handX - lastHandX) * 2; // Чувствительность перемещения
        const currentPosition = triangleEntity.getAttribute('position');
        triangleEntity.setAttribute('position', `${currentPosition.x + deltaX} ${currentPosition.y} ${currentPosition.z}`);
      }
      lastHandX = handX;

      // Обновляем состояние сжатия
      lastPinch = isPinching;

      if (!isPinching) {
        document.getElementById('gesture-info').innerText = `Gesture: Rotate (Angle: ${(palmAngle * 180 / Math.PI).toFixed(2)}°)`;
      }
    }

    // Запускаем обработку жестов в цикле
    function animate() {
      requestAnimationFrame(animate);
      handleGestures();
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
