<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AR + –ñ–µ—Å—Ç—ã (three.js + WebXR)</title>
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; width: 100%; height: 100%; }
    #cam {
      position: absolute; top: 0; left: 0;
      width: 100%; height: 100%;
      object-fit: cover;
      transform: scaleX(-1);
    }
    #three-canvas {
      position: absolute; top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
    }
  </style>

  <!-- VConsole –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏ -->
  <script src="https://unpkg.com/vconsole@3.15.0/dist/vconsole.min.js"></script>
  <script>new VConsole();</script>

  <!-- three.js —á–µ—Ä–µ–∑ CDN -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
</head>
<body>
  <video id="cam" autoplay playsinline muted></video>
  <canvas id="three-canvas"></canvas>

  <script>
    // 1) –ó–∞–ø—É—Å–∫ –∫–∞–º–µ—Ä—ã
    const video = document.getElementById('cam');
    navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } })
      .then(stream => {
        console.log('üé• –ö–∞–º–µ—Ä–∞ –∑–∞–ø—É—â–µ–Ω–∞');
        video.srcObject = stream;
      })
      .catch(err => {
        console.error('–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –∫–∞–º–µ—Ä–µ:', err);
        alert('–ù–µ —É–¥–∞–ª–æ—Å—å –≤–∫–ª—é—á–∏—Ç—å –∫–∞–º–µ—Ä—É:\n' + err.message);
      });

    // 2) –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è three.js
    const canvas = document.getElementById('three-canvas');
    const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.xr.enabled = true; // –í–∫–ª—é—á–∞–µ–º WebXR

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 100);
    camera.position.set(0, 0, 1);
    scene.add(new THREE.HemisphereLight(0xffffbb, 0x080820, 1));

    // 3) –°–æ–∑–¥–∞–Ω–∏–µ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞
    const geometry = new THREE.BufferGeometry();
    const vertices = new Float32Array([
      0, 0.2, 0,
      -0.2, -0.2, 0,
      0.2, -0.2, 0
    ]);
    geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
    const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
    const triangle = new THREE.Mesh(geometry, material);
    triangle.scale.set(0.2, 0.2, 0.2);
    scene.add(triangle);

    // 4) WebXR Hand Tracking
    let session = null;
    let hands = [];
    async function startXR() {
      if (!navigator.xr) {
        console.error('WebXR –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è');
        alert('–í–∞—à –±—Ä–∞—É–∑–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç WebXR');
        return;
      }

      try {
        session = await navigator.xr.requestSession('immersive-ar', {
          requiredFeatures: ['hand-tracking']
        });

        renderer.xr.setSession(session);
        session.addEventListener('inputsourceschange', () => {
          hands = session.inputSources.filter(source => source.hand);
        });

        console.log('‚úÖ WebXR —Å–µ—Å—Å–∏—è –∑–∞–ø—É—â–µ–Ω–∞');
      } catch (err) {
        console.error('–û—à–∏–±–∫–∞ WebXR:', err);
        alert('–û—à–∏–±–∫–∞ WebXR: ' + err.message);
      }
    }

    // 5) –û–±—Ä–∞–±–æ—Ç–∫–∞ –∂–µ—Å—Ç–æ–≤
    let prevDist = null, prevAng = null;
    function onHands(frame) {
      if (!triangle || !session || !frame) return;

      const handData = [];
      for (const inputSource of session.inputSources) {
        if (inputSource.hand) {
          const wrist = inputSource.hand.get('wrist');
          if (wrist) {
            const pose = frame.getJointPose(wrist, renderer.xr.getReferenceSpace());
            if (pose) {
              handData.push({
                x: pose.transform.position.x,
                y: pose.transform.position.y
              });
            }
          }
        }
      }

      console.log('–†—É–∫ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–æ:', handData.length);

      // –û–¥–Ω–∞ —Ä—É–∫–∞: –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ
      if (handData.length === 1) {
        const nx = handData[0].x * 2;
        const ny = handData[0].y * 2;
        triangle.position.set(nx * 0.5, ny * 0.5, 0);
      }
      // –î–≤–µ —Ä—É–∫–∏: –º–∞—Å—à—Ç–∞–± –∏ –≤—Ä–∞—â–µ–Ω–∏–µ
      else if (handData.length === 2) {
        const A = handData[0];
        const B = handData[1];

        const dist = Math.hypot(A.x - B.x, A.y - B.y);
        if (prevDist !== null) {
          const sf = dist / prevDist;
          triangle.scale.multiplyScalar(sf);
        }
        prevDist = dist;

        const ang = Math.atan2(B.y - A.y, B.x - A.x);
        if (prevAng !== null) {
          triangle.rotation.z += ang - prevAng;
        }
        prevAng = ang;
      } else {
        prevDist = prevAng = null;
      }
    }

    // 6) –ê–Ω–∏–º–∞—Ü–∏—è
    renderer.setAnimationLoop((time, frame) => {
      onHands(frame);
      renderer.render(scene, camera);
    });

    // 7) –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ—Å–∞–π–∑–∞
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // 8) –ó–∞–ø—É—Å–∫ WebXR
    startXR();
  </script>
</body>
</html>
