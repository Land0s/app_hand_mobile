<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AR Triangle with Gesture Control</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { width: 100vw; height: 100vh; display: block; }
    #video { 
      position: absolute; 
      top: 0; 
      left: 0; 
      width: 100%; 
      height: 100%; 
      object-fit: cover; 
      z-index: -1; 
    }
    #status { 
      position: absolute; 
      top: 10px; 
      left: 10px; 
      color: white; 
      background: rgba(0, 0, 0, 0.7); 
      padding: 5px; 
      font-family: Arial, sans-serif; 
    }
    #error { 
      position: absolute; 
      top: 50px; 
      left: 10px; 
      color: red; 
      background: rgba(0, 0, 0, 0.7); 
      padding: 5px; 
      font-family: Arial, sans-serif; 
    }
  </style>
</head>
<body>
  <video id="video" autoplay playsinline></video>
  <div id="status">Gesture: None</div>
  <div id="error"></div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/handpose@0.0.7/dist/handpose.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/fingerpose@0.1.0/dist/fingerpose.min.js"></script>
  <script>
    window.addEventListener('DOMContentLoaded', () => {
      const errorDiv = document.getElementById('error');

      // Check if Three.js is loaded
      if (typeof THREE === 'undefined') {
        errorDiv.textContent = 'Error: Three.js failed to load. Please check your network or CDN.';
        return;
      }

      // Check if fingerpose is loaded
      if (typeof window.fingerpose === 'undefined') {
        errorDiv.textContent = 'Error: fingerpose failed to load. Please check your network or CDN.';
        return;
      }

      // Three.js setup
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Create 3D triangle
      const geometry = new THREE.BufferGeometry();
      const vertices = new Float32Array([
        0, 1, 0,  // Top vertex
        -1, -1, 0, // Bottom-left
        1, -1, 0   // Bottom-right
      ]);
      const indices = [0, 1, 2];
      geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
      geometry.setIndex(indices);
      const material = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide });
      const triangle = new THREE.Mesh(geometry, material);
      scene.add(triangle);
      camera.position.z = 5;

      // Webcam setup
      const video = document.getElementById('video');
      navigator.mediaDevices.getUserMedia({ video: true })
        .then(stream => {
          video.srcObject = stream;
        })
        .catch(err => {
          errorDiv.textContent = 'Webcam error: ' + err.message;
        });

      // Gesture recognition setup
      const status = document.getElementById('status');
      let lastGesture = null;

      // Define custom gestures
      const GE = window.fingerpose.Gestures;
      const PinchGesture = new window.fingerpose.GestureDescription('pinch');
      PinchGesture.addCurl(window.fingerpose.Finger.Thumb, window.fingerpose.FingerCurl.NoCurl);
      PinchGesture.addCurl(window.fingerpose.Finger.Index, window.fingerpose.FingerCurl.FullCurl);
      for (let finger of [window.fingerpose.Finger.Middle, window.fingerpose.Finger.Ring, window.fingerpose.Finger.Pinky]) {
        PinchGesture.addCurl(finger, window.fingerpose.FingerCurl.NoCurl);
      }

      const RotateGesture = new window.fingerpose.GestureDescription('rotate');
      for (let finger of window.fingerpose.Finger.all) {
        RotateGesture.addCurl(finger, window.fingerpose.FingerCurl.NoCurl);
        RotateGesture.addDirection(finger, window.fingerpose.FingerDirection.DiagonalUpRight, 1.0);
        RotateGesture.addDirection(finger, window.fingerpose.FingerDirection.DiagonalUpLeft, 0.9);
      }

      // Load handpose model
      async function initHandpose() {
        if (!window.handpose) {
          errorDiv.textContent = 'Error: Handpose model failed to load.';
          return;
        }
        try {
          const model = await window.handpose.load();
          detectGestures(model);
        } catch (err) {
          errorDiv.textContent = 'Error loading handpose model: ' + err.message;
        }
      }

      async function detectGestures(model) {
        if (video.readyState === 4) {
          try {
            const predictions = await model.estimateHands(video);
            if (predictions.length > 0) {
              const gestureEstimator = new window.fingerpose.GestureEstimator([PinchGesture, RotateGesture]);
              const gesture = gestureEstimator.estimate(predictions[0].landmarks, 8);
              if (gesture.gestures.length > 0) {
                const bestGesture = gesture.gestures.reduce((a, b) => a.score > b.score ? a : b);
                lastGesture = bestGesture.name;
                status.textContent = `Gesture: ${lastGesture}`;
                // Control triangle
                if (lastGesture === 'pinch') {
                  triangle.scale.multiplyScalar(0.99); // Scale down
                } else if (lastGesture === 'rotate') {
                  triangle.rotation.z += 0.05; // Rotate
                }
              } else {
                status.textContent = 'Gesture: None';
              }
            }
          } catch (err) {
            errorDiv.textContent = 'Gesture detection error: ' + err.message;
          }
        }
        requestAnimationFrame(() => detectGestures(model));
      }

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
      }

      // Handle window resize
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Start
      initHandpose();
      animate();
    });
  </script>
</body>
</html>
