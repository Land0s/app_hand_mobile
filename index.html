<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AR + –ñ–µ—Å—Ç—ã (three.js + handtrack.js)</title>
  <style>
    html, body { margin:0; padding:0; overflow:hidden; width:100%; height:100%; }
    #cam {
      position:absolute; top:0; left:0;
      width:100%; height:100%;
      object-fit:cover;
      transform:scaleX(-1);
    }
    #three-canvas {
      position:absolute; top:0; left:0;
      width:100%; height:100%;
      pointer-events:none;
    }
  </style>

  <!-- VConsole for debugging -->
  <script src="https://unpkg.com/vconsole@3.15.0/dist/vconsole.min.js"></script>
  <script>new VConsole();</script>
  
  <!-- three.js and GLTFLoader -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/loaders/GLTFLoader.js"></script>
  
  <!-- handtrack.js -->
  <script src="https://cdn.jsdelivr.net/npm/handtrackjs@0.1.8/dist/handtrack.min.js"></script>
</head>
<body>
  <video id="cam" autoplay playsinline muted></video>
  <canvas id="three-canvas"></canvas>

  <script>
    // 1) Camera setup
    const video = document.getElementById('cam');
    navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } })
      .then(stream => {
        console.log('üé• –ö–∞–º–µ—Ä–∞ –∑–∞–ø—É—â–µ–Ω–∞');
        video.srcObject = stream;
      })
      .catch(err => {
        console.error('–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –∫–∞–º–µ—Ä–µ:', err);
        alert('–ù–µ —É–¥–∞–ª–æ—Å—å –≤–∫–ª—é—á–∏—Ç—å –∫–∞–º–µ—Ä—É:\n' + err.message);
      });

    // 2) three.js setup
    const canvas = document.getElementById('three-canvas');
    const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setClearColor(0xff0000, 0.3);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 100);
    camera.position.set(0, 0, 1);
    scene.add(new THREE.HemisphereLight(0xffffbb, 0x080820, 1));

    // 3) Create triangle
    const geometry = new THREE.BufferGeometry();
    const vertices = new Float32Array([
      0, 0.5, 0,   // Top
      -0.5, -0.5, 0, // Bottom-left
      0.5, -0.5, 0  // Bottom-right
    ]);
    geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
    const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
    const triangle = new THREE.Mesh(geometry, material);
    triangle.scale.set(0.2, 0.2, 0.2);
    scene.add(triangle);

    // 4) handtrack.js setup
    const modelParams = {
      flipHorizontal: true,
      maxNumBoxes: 2,
      iouThreshold: 0.5,
      scoreThreshold: 0.7
    };
    let model = null;
    handTrack.load(modelParams).then(lmodel => {
      console.log('‚úÖ handtrack.js –∑–∞–≥—Ä—É–∂–µ–Ω');
      model = lmodel;
      startHandTrack();
    });

    // 5) Start hand tracking
    function startHandTrack() {
      handTrack.startVideo(video).then(status => {
        if (status) {
          console.log('–í–∏–¥–µ–æ –∑–∞–ø—É—â–µ–Ω–æ –¥–ª—è handtrack.js');
          detectHands();
        } else {
          console.error('–û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ –≤–∏–¥–µ–æ –¥–ª—è handtrack.js');
        }
      });
    }

    // 6) Hand detection and interaction
    let prevDist = null, prevAng = null;
    function detectHands() {
      if (!model || !triangle) return;
      model.detect(video).then(predictions => {
        console.log('–†—É–∫ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–æ:', predictions.length);

        // Single hand: move triangle
        if (predictions.length === 1) {
          const box = predictions[0].bbox;
          const nx = (box[0] + box[2] / 2) / video.videoWidth * 2 - 1;
          const ny = -((box[1] + box[3] / 2) / video.videoHeight * 2 - 1);
          triangle.position.set(nx * 0.5, ny * 0.5, 0);
        }
        // Two hands: scale and rotate
        else if (predictions.length === 2) {
          const A = {
            x: (predictions[0].bbox[0] + predictions[0].bbox[2] / 2) / video.videoWidth,
            y: (predictions[0].bbox[1] + predictions[0].bbox[3] / 2) / video.videoHeight
          };
          const B = {
            x: (predictions[1].bbox[0] + predictions[1].bbox[2] / 2) / video.videoWidth,
            y: (predictions[1].bbox[1] + predictions[1].bbox[3] / 2) / video.videoHeight
          };
          // Scale
          const dist = Math.hypot(A.x - B.x, A.y - B.y);
          if (prevDist !== null) {
            const sf = dist / prevDist;
            triangle.scale.multiplyScalar(sf);
          }
          prevDist = dist;
          // Rotation
          const ang = Math.atan2(B.y - A.y, B.x - A.x);
          if (prevAng !== null) {
            triangle.rotation.z += ang - prevAng;
          }
          prevAng = ang;
        } else {
          prevDist = prevAng = null;
        }
        requestAnimationFrame(detectHands);
      });
    }

    // 7) Animation loop
    (function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    })();

    // 8) Handle resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
