<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AR + –ñ–µ—Å—Ç—ã (three.js + handtrack.js)</title>
  <style>
    html, body { margin:0; padding:0; overflow:hidden; width:100%; height:100%; }
    #cam {
      position:absolute; top:0; left:0;
      width:100%; height:100%;
      object-fit:cover;
      transform:scaleX(-1);
    }
    #three-canvas {
      position:absolute; top:0; left:0;
      width:100%; height:100%;
      pointer-events:none;
    }
  </style>

  <!-- VConsole –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏ -->
  <script src="https://unpkg.com/vconsole@3.15.0/dist/vconsole.min.js"></script>
  <script>new VConsole();</script>

  <!-- three.js —á–µ—Ä–µ–∑ CDN -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

  <!-- handtrack.js —á–µ—Ä–µ–∑ CDN -->
  <script src="https://cdn.jsdelivr.net/npm/handtrackjs@0.1.8/dist/handtrack.min.js"></script>
</head>
<body>
  <video id="cam" autoplay playsinline muted></video>
  <canvas id="three-canvas"></canvas>

  <script>
    // 1) –ó–∞–ø—É—Å–∫ –∫–∞–º–µ—Ä—ã
    const video = document.getElementById('cam');
    navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } })
      .then(stream => {
        console.log('üé• –ö–∞–º–µ—Ä–∞ –∑–∞–ø—É—â–µ–Ω–∞');
        video.srcObject = stream;
      })
      .catch(err => {
        console.error('–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –∫–∞–º–µ—Ä–µ:', err);
        alert('–ù–µ —É–¥–∞–ª–æ—Å—å –≤–∫–ª—é—á–∏—Ç—å –∫–∞–º–µ—Ä—É:\n' + err.message);
      });

    // 2) –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è three.js
    const canvas = document.getElementById('three-canvas');
    const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setClearColor(0xff0000, 0.3);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 100);
    camera.position.set(0, 0, 1);
    scene.add(new THREE.HemisphereLight(0xffffbb, 0x080820, 1));

    // 3) –°–æ–∑–¥–∞–Ω–∏–µ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞
    const geometry = new THREE.BufferGeometry();
    const vertices = new Float32Array([
      0, 0.2, 0,  // –í–µ—Ä—à–∏–Ω–∞ 1
      -0.2, -0.2, 0, // –í–µ—Ä—à–∏–Ω–∞ 2
      0.2, -0.2, 0  // –í–µ—Ä—à–∏–Ω–∞ 3
    ]);
    geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
    geometry.computeVertexNormals();
    const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
    const triangle = new THREE.Mesh(geometry, material);
    triangle.scale.set(0.5, 0.5, 0.5); // –ù–∞—á–∞–ª—å–Ω—ã–π –º–∞—Å—à—Ç–∞–±
    scene.add(triangle);

    // 4) –ù–∞—Å—Ç—Ä–æ–π–∫–∞ handtrack.js
    let model = null;
    handTrack.load({
      flipHorizontal: true, // –ó–µ—Ä–∫–∞–ª–∏–º –¥–ª—è —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è –≤–∏–¥–µ–æ
      maxNumBoxes: 2,      // –î–æ –¥–≤—É—Ö —Ä—É–∫
      iouThreshold: 0.5,
      scoreThreshold: 0.7
    }).then(lmodel => {
      console.log('‚úÖ Handtrack.js –º–æ–¥–µ–ª—å –∑–∞–≥—Ä—É–∂–µ–Ω–∞');
      model = lmodel;
      startHandTracking();
    }).catch(err => {
      console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ handtrack.js:', err);
      alert('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –º–æ–¥–µ–ª—å handtrack.js:\n' + err.message);
    });

    // 5) –ó–∞–ø—É—Å–∫ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è —Ä—É–∫
    function startHandTracking() {
      if (!model) return;
      model.detect(video).then(predictions => {
        handleHands(predictions);
        requestAnimationFrame(startHandTracking); // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –æ—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å
      }).catch(err => {
        console.error('–û—à–∏–±–∫–∞ –≤ handtrack.js detect:', err);
      });
    }

    // 6) –§—É–Ω–∫—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∂–µ—Å—Ç–æ–≤
    let prevDist = null, prevAng = null;
    function handleHands(predictions) {
      console.log('–†—É–∫ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–æ:', predictions.length);
      if (!triangle) return;

      // –û–¥–Ω–∞ —Ä—É–∫–∞: –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ
      if (predictions.length === 1) {
        const box = predictions[0].bbox;
        const nx = (box[0] + box[2] / 2) / video.videoWidth * 2 - 1; // –¶–µ–Ω—Ç—Ä –ø–æ X
        const ny = -((box[1] + box[3] / 2) / video.videoHeight * 2 - 1); // –¶–µ–Ω—Ç—Ä –ø–æ Y
        triangle.position.set(nx * 0.5, ny * 0.5, 0);
      }
      // –î–≤–µ —Ä—É–∫–∏: –º–∞—Å—à—Ç–∞–± –∏ –≤—Ä–∞—â–µ–Ω–∏–µ
      else if (predictions.length === 2) {
        const A = predictions[0].bbox;
        const B = predictions[1].bbox;
        const Ax = (A[0] + A[2] / 2) / video.videoWidth;
        const Ay = (A[1] + A[3] / 2) / video.videoHeight;
        const Bx = (B[0] + B[2] / 2) / video.videoWidth;
        const By = (B[1] + B[3] / 2) / video.videoHeight;

        // –ú–∞—Å—à—Ç–∞–±
        const dist = Math.hypot(Ax - Bx, Ay - By);
        if (prevDist !== null) {
          const sf = dist / prevDist;
          triangle.scale.multiplyScalar(sf);
        }
        prevDist = dist;

        // –í—Ä–∞—â–µ–Ω–∏–µ
        const ang = Math.atan2(By - Ay, Bx - Ax);
        if (prevAng !== null) {
          triangle.rotation.z += ang - prevAng;
        }
        prevAng = ang;
      } else {
        prevDist = prevAng = null;
      }
    }

    // 7) –ê–Ω–∏–º–∞—Ü–∏—è
    (function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    })();

    // 8) –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ—Å–∞–π–∑–∞
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
